/*
 * @(#)PunchscanCommitmentScheme.java
 *  
 * Copyright (C) 2008-2011 Scantegrity Project
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */


package org.scantegrity.crypto;

import java.security.Key;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Arrays;

import javax.crypto.Cipher;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.SecretKeySpec;

/**
 * This class generates commitments from the original Punchscan scheme.
 * The real security of this commitment scheme is unknown, and there may be 
 * unknown flaws (we don't think there are, however). The scheme is described 
 * as follows:   
 * 
 * Given a message m, a secretKey skm and a public constant 
 * it returns the commitment to the message m.
 * The commitment is computed as follows:
 * sak=Encrypt C with skm
 * h1 = SHA256(m, sak).
 * h2 = SHA256(m, Encrypt h1 with sak)
 * the commitment is h1h2 (h1 concatenated with h2)
 * where E stands for Encrypt.
 * The encryption scheme used is AES/ECB/NoPadding
 * 
 * In Punchscan, the SKM was mk1, mk2, c, the ballot serial number concatenated with "P1" or 
 * "P2" which was then hashed by a "tripleAES" function, which did: 
 * Km = Dmk1 (C XOR Emk2 (C XOR Emk1(message))),
 * where D stands for decrypt and E for Encrypt. Emk1 means Encrypt with the key "mk1"
 * (master key 1). The encryption scheme used is AES/ECB/NoPadding
 * 
 * In this implementation, we assume salt (skm) is generated by a secure PRNG 
 * that has already been pre-seeded. Users wishing to use the Punchscan seeding 
 * method should use a salt generator which uses the above method. The actual
 * specification for the commitments only require that we publish the salt
 * used to generate the commitment.   
 * 
 * Also to be noted, the Cipher used by Punchscan was "AES/ECB/NoPadding", 
 * whereas our cipher is configured by the user of this class.
 * 
 * @author carback1
 * @version 0.0.1
 * @date March 5th, 2011
 */
public enum PunchscanCommitmentScheme implements CommitmentScheme {
	INSTANCE;
	
	private byte[] c_const = null;
	private Cipher c_cipher = null;
	private MessageDigest c_digest = null;
	private SecureRandom c_sprng = null;
	private int c_keylen = 0;
	private String c_alg = "";
	
	/**
	 * NOTICE: Message Digest should be SHA256 and Cipher should be 
	 * AES/ECB/NoPadding for this commitment scheme to match the Punchscan
	 * specifications. 
	 * 
	 * At the very least, you should have a cipher which produces block sizes
	 * that are the same as the key length.
	 * 
	 * @param p_cipher The cipher to use.
	 * @param p_digest The digest algorithm to use. 
	 * @param p_const A public constant
	 * @throws NoSuchAlgorithmException 
	 */
	public boolean initialize(Cipher p_cipher, MessageDigest p_digest, 
			byte[] p_const)
	{
		c_cipher = p_cipher;
		c_digest = p_digest;
		c_const = p_const;
		c_alg = p_cipher.getAlgorithm();
		return true;
	}
	
	/** 
	 * Given a message m, a secretKey skm and a public constant 
	 * it returns the commitment to the message m.
	 * The commitment is computed as follows:
	 * sak=Encrypt C with skm
	 * h1 = SHA256(m, sak).
	 * h2 = SHA256(m, Encrypt h1 with sak)
	 * the commitment is h1h2 (h1 concatenated with h2)
	 * where E stands for Encrypt.
	 * The encryption scheme used is AES/ECB/NoPadding
	 * 
	 * @see org.scantegrity.crypto.CommitmentScheme#commit(byte[], byte[])
	 *  
	 * @param p_key the salt
	 * @param p_msg the message to commit
	 */
	@Override
	public byte[] commit(byte[] p_key, byte[] p_msg) throws Exception {
		byte[] h1, h2, l_ret;
		c_sprng.nextBytes(p_key);
				
		//sak=Encrypt C with salt
		c_cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(p_key, c_alg));
		byte[] l_sak = c_cipher.doFinal(c_const);
		
		//h1 = SHA256(m, sak).
		c_digest.reset();
		c_digest.update(p_msg);
		h1 = c_digest.digest(l_sak);
		
		//h2 = SHA256(m, Encrypt h1 with sak)
		c_digest.reset();
		c_digest.update(p_msg);
		c_cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(l_sak, c_alg));
		h2 = c_digest.digest(c_cipher.doFinal(h1));
		
		// the commitment is h1h2 (h1 concatenated with h2)
		l_ret = new byte[h1.length+h2.length]; 
		System.arraycopy(h1, 0, l_ret, 0, h1.length);
		System.arraycopy(h2, 0, l_ret, h1.length, h2.length);
		
		return l_ret;
	}

	/* (non-Javadoc)
	 * @see org.scantegrity.crypto.CommitmentScheme#verify(byte[], byte[], byte[])
	 */
	@Override
	public boolean verify(byte[] p_commit, byte[] p_key, byte[] p_msg) {
		try {
			byte[] l_tst = commit(p_key, p_msg);
			if (Arrays.equals(l_tst, p_commit)) return true;
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return false;
	}

}
